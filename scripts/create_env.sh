#!/usr/bin/env bash
# Interactive helper to create a local .env file for development.
# This script will NOT commit the .env file. It writes to .env and ensures
# .env is ignored by git. Use this only for local development.

set -euo pipefail

ROOT_DIR=$(cd "$(dirname "$(dirname "$0")")" >/dev/null 2>&1 && pwd)
ENV_FILE="$ROOT_DIR/.env"

echo "This script will create a local .env file at: $ENV_FILE"
echo "Do NOT paste production secrets into public places; keep this file local."

read -rp "SECRET_KEY (leave empty to generate a random key): " USER_SECRET
if [ -z "$USER_SECRET" ]; then
  # Use Django's recommended get_random_secret_key if available; otherwise fallback.
  if command -v python3 >/dev/null 2>&1; then
    # Run python in a conditional so failures (e.g. django not installed) don't
    # cause the whole script to exit because of set -e.
    if USER_SECRET=$(python3 - <<'PY' 2>/dev/null
from django.core.management.utils import get_random_secret_key
print(get_random_secret_key())
PY
); then
      :
    else
      USER_SECRET=$(head -c 32 /dev/urandom | base64)
    fi
  else
    USER_SECRET=$(head -c 32 /dev/urandom | base64)
  fi
fi

read -rp "DEBUG (True/False) [False]: " USER_DEBUG
USER_DEBUG=${USER_DEBUG:-False}

read -rp "ALLOWED_HOSTS (comma separated) [127.0.0.1,localhost]: " USER_ALLOWED
USER_ALLOWED=${USER_ALLOWED:-127.0.0.1,localhost}

read -rp "DATABASE_URL (optional, leave empty to use sqlite): " USER_DB
USER_DB=${USER_DB:-}

read -rp "DISABLE_COLLECTSTATIC (1 to disable) [1]: " USER_DISABLE_COLLECTSTATIC
USER_DISABLE_COLLECTSTATIC=${USER_DISABLE_COLLECTSTATIC:-1}

cat > "$ENV_FILE" <<EOF
# Local .env generated by scripts/create_env.sh â€” DO NOT COMMIT
SECRET_KEY=${USER_SECRET}
DEBUG=${USER_DEBUG}
ALLOWED_HOSTS=${USER_ALLOWED}
DISABLE_COLLECTSTATIC=${USER_DISABLE_COLLECTSTATIC}
EOF

if [ -n "$USER_DB" ]; then
  printf "\nDATABASE_URL=%s\n" "$USER_DB" >> "$ENV_FILE"
fi

echo "Wrote $ENV_FILE"

# Ensure .env is ignored by git (operate in the project root)
if git -C "$ROOT_DIR" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  if git -C "$ROOT_DIR" ls-files --error-unmatch -- .env >/dev/null 2>&1; then
    echo ".env is already tracked by git (you should remove it manually if needed)."
  else
    GITIGNORE="$ROOT_DIR/.gitignore"
    # Ensure .gitignore exists
    if [ ! -f "$GITIGNORE" ]; then
      touch "$GITIGNORE"
      git -C "$ROOT_DIR" add .gitignore || true
    fi
    if ! grep -qxF ".env" "$GITIGNORE" 2>/dev/null; then
      echo ".env" >> "$GITIGNORE"
      git -C "$ROOT_DIR" add .gitignore || true
      git -C "$ROOT_DIR" commit -m "chore: ignore local .env" || true
      echo "Added .env to .gitignore"
    else
      echo ".env already present in .gitignore"
    fi
  fi
fi

echo "Done. Your local .env is ready and ignored by git."
